{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"aurora","usesPingPong":false,"texture":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uCustomTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;ivec2 customTexSize;\nfloat customTexAspect;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\nreturn a + b*cos( TAU*(c*t+d) );\n}vec3 Tonemap_Reinhard(vec3 x) {\nx *= 4.;\nreturn x / (1.0 + x);\n}float sdCircle(vec2 st, float r) {\nreturn length(st) - r;\n}float getSdf(vec2 st, float iter, float md) {\nreturn sdCircle(st, 0.3480);\n}vec2 turb(vec2 pos, float t, float it, float md, vec2 mPos) {\nmat2 rot = mat2(0.6, -0.8, 0.8, 0.6);\nfloat freq = mix(2., 15., 0.5000);\nfloat amp = (0.5000) * md;\nfloat xp = 1.4;\nfloat time = t * 0.1 + 0.0000;\nfor(float i = 0.; i < 4.; i++) {\nvec2 s = sin(freq * ((pos - mPos) * rot) + i * time + it);\npos += amp * rot[0] * s / freq;\nrot *= mat2(0.6, -0.8, 0.8, 0.6);\namp *= mix(1., max(s.y, s.x), 0.0000);\nfreq *= xp;\n}return pos;\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}const float ITERATIONS = 36.;void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);if(1 == 0) {\ncustomTexSize = textureSize(uCustomTexture, 0);\ncustomTexAspect = float(customTexSize.x) / float(customTexSize.y);\n}\nvec3 pp = vec3(0.);\nvec3 bloom = vec3(0.);\nfloat t = uTime * 0.5 + 0.0000;\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);\nvec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 pos = (uv * aspect - vec2(0.5, 0.5) * aspect);\nfloat mDist = length(uv * aspect - uMousePos * aspect);\nfloat md = mix(1., smoothstep(1., 5., 1./mDist), 0.0000);\nfloat rotation = -0.0945 * -2.0 * 3.14159265359;\nmat2 rotMatrix = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\npos = rotMatrix * pos;\nfloat bm = 0.05;\nvec2 prevPos = turb(pos, t, 0. - 1./ITERATIONS, md, mousePos);\nfloat spacing = mix(1., TAU, 0.0000);\nfloat smoothing = 0.0000;\nfor(float i = 1.; i < ITERATIONS + 1.; i++) {\nfloat iter = i/ITERATIONS;\nvec2 st = turb(pos, t, iter * spacing, md, mousePos);\nfloat d = abs(getSdf(st, iter, md));\nfloat pd = distance(st, prevPos);\nprevPos = st;\nfloat dynamicBlur = exp2(pd * 2.0 * 1.4426950408889634) - 1.0;\nfloat ds = smoothstep(0., 1.0000 * bm + max(dynamicBlur * smoothing, 0.001), d);\nvec3 color = pal(iter * mix(0.1, 1.9, 0.1000) + 0.5400, vec3(0.5), vec3(0.5), vec3(1), vec3(0.0784313725490196, 0, 0.17647058823529413));\nfloat invd = 1./max(d + dynamicBlur, 0.001);\npp += (ds - 1.) * color;\nbloom += clamp(invd, 0., 250.) * color;\n}pp *= 1./ITERATIONS;\nbloom = bloom / (bloom + 2e4);vec3 color = (-pp + bloom * 3. * 0.7500);\ncolor *= 1.2;\ncolor += (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor = (Tonemap_Reinhard(color));\nvec4 auroraColor = vec4(color, 1.);\nauroraColor.rgb = blend(1, bg.rgb, auroraColor.rgb);auroraColor = vec4(mix(bg.rgb, auroraColor.rgb, 1.0000), max(bg.a, luma(auroraColor.rgb)));\nfragColor = auroraColor;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"voronoi","usesPingPong":false,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nvec2 random2( vec2 p ) {\nreturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}const float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nout vec4 fragColor;vec2 voronoidNoise(vec2 st) {\nvec2 i_st = floor(st);\nvec2 f_st = fract(st);float m_dist = 15.;\nvec2 m_point;\nvec2 d;for (int j=-1; j<=1; j++ ) {\nfor (int i=-1; i<=1; i++ ) {\nvec2 neighbor = vec2(float(i),float(j));\nvec2 point = random2(i_st + neighbor);point = 0.5 + 0.5 * sin(5. + uTime * 0.2 + 6.2831*point);\nvec2 diff = neighbor + point - f_st;\nfloat dist = length(diff);if( dist < m_dist ) {\nm_dist = dist;\nm_point = point;\nd = diff;\n}\n}\n}return m_point;\n}\nvec2 voronoiFBM(vec2 st) {\nvec2 value = vec2(0.0);\nvec2 shift = vec2(100.0);\nfloat xp = sqrt(2.);\nmat2 r = rot(0.5);\nfor (int i = 0; i < 6; i++) {\nvalue += voronoidNoise(st);\nst = st * xp + shift;\nst = r * st;\n}\nreturn value / float(6);\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 skew = mix(vec2(1), vec2(1, 0), 1.0000);vec2 st = (uv - vec2(0.5, 0.5)) * vec2(aspectRatio, 1.) * 50. * 0.3100;\nst = st * rot(0.1053 * 2. * PI) * skew;\nvec2 m_point = voronoiFBM(st);vec2 offset = (m_point * 0.2 * 0.3400 * 2.) - (0.3400 * 0.2);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));vec4 color = texture(uTexture, uv + offset * dist);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"}],"options":{"name":"Breakthrough (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.5.3","id":"f3JLVdKNQpxZMKUzkm5w"}
