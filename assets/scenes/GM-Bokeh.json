{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform float uTime;\nuniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.17647058823529413, 0, 0.3411764705882353);\ncase 1: return vec3(0.25882352941176473, 0, 0.5176470588235295);\ncase 2: return vec3(0.5019607843137255, 0, 1);\ncase 3: return vec3(0.5294117647058824, 0.07058823529411765, 1);\ncase 4: return vec3(0.6470588235294118, 0.47843137254901963, 1);\ncase 5: return vec3(0.9882352941176471, 0.9176470588235294, 1);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.2000;\ncase 2: return 0.4000;\ncase 3: return 0.6000;\ncase 4: return 0.8000;\ncase 5: return 1.0000;\ncase 6: return 0.0000;\ncase 7: return 0.0000;\ncase 8: return 0.0000;\ncase 9: return 0.0000;\ncase 10: return 0.0000;\ncase 11: return 0.0000;\ncase 12: return 0.0000;\ncase 13: return 0.0000;\ncase 14: return 0.0000;\ncase 15: return 0.0000;\ndefault: return 0.0;\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}float rand(vec2 co) {\nreturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(rgb, vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(lin, vec3(1.0/2.2));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);\nvec3 lms1 = pow( kCONEtoLMS*lin1, vec3(1.0/3.0) );\nvec3 lms2 = pow( kCONEtoLMS*lin2, vec3(1.0/3.0) );\nvec3 lms = mix( lms1, lms2, a );\nlms *= 1.0 + 0.025 * a * (1.0-a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nfor (int i = 0; i < 6 - 1; i++) {\nfloat colorPosition = getStop(i);\nfloat nextColorPosition = getStop(i + 1);\nif (position <= nextColorPosition) {\nfloat mixFactor = (position - colorPosition) / (nextColorPosition - colorPosition);\nvec3 linStart = linear_from_srgb(getColor(i));\nvec3 linEnd = linear_from_srgb(getColor(i + 1));\nvec3 mixedLin = oklab_mix(linStart, linEnd, mixFactor);\nreturn srgb_from_linear(mixedLin);\n}\n}\nreturn getColor(6 - 1);\n}out vec4 fragColor;vec3 applyColorToPosition(float position) {\nvec3 color = vec3(0);\nposition -= (uTime * 0.01 + 0.0000);\nfloat cycle = floor(position);\nbool reverse = 1.0000 > 0.5 && int(cycle) % 2 == 0;\nfloat animatedPos = reverse ? 1.0 - fract(position) : fract(position);color = getGradientColor(animatedPos);\nfloat dither = rand(gl_FragCoord.xy) * 0.005;\ncolor += dither;\nreturn color;\n}vec3 linearGrad(vec2 uv) {\nfloat position = (uv.x+0.5);\nreturn applyColorToPosition(position);\n}vec3 getGradient(vec2 uv) {\nreturn linearGrad(uv);\n}vec3 getColor(vec2 uv) {return getGradient(uv);return vec3(0.17647058823529413, 0, 0.3411764705882353);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[{"max":null,"props":{"left":0.21335087747925513,"top":0.7041021014201092,"height":0.21259941924015685,"width":0.49660178547135064},"name":"Desktop","min":992},{"min":0,"props":{"width":1.159238705738706,"left":0.38991666666666663,"height":0.4962798822135489,"top":0.7564337799693337},"max":575,"name":"Mobile"}],"aspectRatio":1.0793650793650795,"userDownsample":1,"effects":[],"anchorPoint":8,"mask":0,"maskDepthLayer":1,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":0.49660178547135064,"widthMode":0,"height":0.7361391172869431,"heightMode":2,"left":0.21335087747925513,"top":0.7041021014201092,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(1, 1, 1);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}uniform vec2 uArtboardResolution;\nuniform float uWidth;\nuniform float uHeight;\nuniform float uLeft;\nuniform float uTop;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.5);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;return getColor(0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdEllipse(vec2 p, vec2 ab) {\nvec2 q = p / ab;\nreturn (length(q) - 1.0) * min(ab.x, ab.y);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;return sdEllipse(p, vec2(max(halfSize.x, 0.00001), max(halfSize.y, 0.00001)));\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = uWidth * uArtboardResolution.x;\nfloat absHeight = uHeight * uArtboardResolution.y;if (0 == 2) {\nabsWidth = absHeight * 1.0794;\n} else if (2 == 2) {\nabsHeight = absWidth / 1.0794;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(uLeft, uTop) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = rotate2D(canvasPosPx - (elementPosPx + elementSizePx * 0.5), 0.0000 * -TAU) + elementSizePx * 0.5;\nvec2 localSize;\nlocalSize = elementSizePx;\nvec2 centerPx;\ncenterPx = elementPosPx + elementSizePx * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(4, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 0.8200);\ncolor = color + background * (1.0 - color.a);\nreturn color;\nreturn mix(background, color + background * (1.0 - color.a), 0.8200);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 getCompositeOutput(vec2 uv) {\nvec4 background = vec4(0.0);background = texture(uBgTexture, vTextureCoord);vec4 color = sampleShape(uv);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0000;uv -= pos;fragColor = getCompositeOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.0793650793650795},"width":{"name":"uWidth","type":"1f","value":512},"left":{"name":"uLeft","type":"1f","value":0},"height":{"name":"uHeight","type":"1f","value":512},"top":{"name":"uTop","type":"1f","value":0}}},"id":"shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"blur","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.49931874120956404, 0.6111111111111112) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 0 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 0 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.49931874120956404, 0.6111111111111112) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 1 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 1 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.49931874120956404, 0.6111111111111112) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 2 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 2 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const int kernelSize = 36;\nfloat getGaussianWeight(int index) {\nswitch(index) {\ncase 0: return 0.00094768;\ncase 1: return 0.00151965;\ncase 2: return 0.00237008;\ncase 3: return 0.00359517;\ncase 4: return 0.0053041;\ncase 5: return 0.00761097;\ncase 6: return 0.01062197;\ncase 7: return 0.01441804;\ncase 8: return 0.01903459;\ncase 9: return 0.0244409;\ncase 10: return 0.03052299;\ncase 11: return 0.03707432;\ncase 12: return 0.04379813;\ncase 13: return 0.05032389;\ncase 14: return 0.05623791;\ncase 15: return 0.06112521;\ncase 16: return 0.06461716;\ncase 17: return 0.06643724;\ncase 18: return 0.06643724;\ncase 19: return 0.06461716;\ncase 20: return 0.06112521;\ncase 21: return 0.05623791;\ncase 22: return 0.05032389;\ncase 23: return 0.04379813;\ncase 24: return 0.03707432;\ncase 25: return 0.03052299;\ncase 26: return 0.0244409;\ncase 27: return 0.01903459;\ncase 28: return 0.01441804;\ncase 29: return 0.01062197;\ncase 30: return 0.00761097;\ncase 31: return 0.0053041;\ncase 32: return 0.00359517;\ncase 33: return 0.00237008;\ncase 34: return 0.00151965;\ncase 35: return 0.00094768;\ndefault: return 0.0;\n}\n}vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nvec2 pos = vec2(0.49931874120956404, 0.6111111111111112) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat inner = distance(uv, pos);\nfloat outer = max(0., 1.-distance(uv, pos));float amt = 3 <= 1 ? 6. : 11.;\nfloat amount = (2.9740 * amt) * ease(0, mix(inner, outer, 0.5000));\ncolor += texture(tex, uv) * getGaussianWeight(0);\nfor (int i = 0; i < kernelSize; i++) {\nfloat x = float(i - kernelSize / 2) * amount;\ncolor += texture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i);\n}\nreturn color;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn GaussianBlur(uTexture, uv, direction);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);\nint dir = 3 % 2;\nvec2 direction = dir == 1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color = blur(uv, direction);float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither;\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"vertical","value":1,"downSample":0.25},{"prop":"vertical","value":2,"downSample":0.5},{"prop":"vertical","value":3,"downSample":0.5}]},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sdf_shape","usesPingPong":false,"texture":false,"speed":0.1,"trackMouseMove":0,"trackAxes":"xy","mouseMomentum":0,"trackMouse":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.141592653;\nconst float PI2 = 6.283185306;\nconst int DISP_STEPS = 12;\nconst vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize;\nfloat customTexAspect;const mat3 ROT_Y_90 = mat3(\n0.0, 0.0, 1.0,\n0.0, 1.0, 0.0,\n-1.0, 0.0, 0.0\n);const mat3 ROT_Z_90 = mat3(\n0.0, -1.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 0.0, 1.0\n);const mat3 ROT_X_90 = mat3(\n1.0, 0.0, 0.0,\n0.0, 0.0, -1.0,\n0.0, 1.0, 0.0\n);mat3 rotY(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}mat3 rotX(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}mat3 rotZ(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}vec3 twistY(vec3 p, float amount) {\nfloat c = cos(amount * p.y);\nfloat s = sin(amount * p.y);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(m * p.xz, p.y);\n}vec3 twistX(vec3 p, float amount) {\nfloat c = cos(amount * p.x);\nfloat s = sin(amount * p.x);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(p.x, m * p.yz);\n}float sdStar5(vec2 p, float r, float rf)\n{\nconst vec2 k1 = vec2(0.809016994375, -0.587785252292);\nconst vec2 k2 = vec2(-k1.x,k1.y);\np.x = abs(p.x);\np -= 2.0*max(dot(k1,p),0.0)*k1;\np -= 2.0*max(dot(k2,p),0.0)*k2;\np.x = abs(p.x);\np.y -= r;\nvec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\nfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\nreturn length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}float smoothMax(float a, float b, float k) {\nfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\nreturn mix(a, b, h) + k * h * (1.0 - h);\n}float sdDodecahedron(vec3 p, float r) {\nconst float phi = (1.0 + sqrt(5.0)) / 2.0;\nconst float a = 1.0;\nconst float b = 1.0 / phi;\nconst float c = 2.0 - phi;vec3 n = abs(p);\nfloat d1 = dot(vec3(a, c, 0), n);\nfloat d2 = dot(vec3(-a, c, 0), n);\nfloat d3 = dot(vec3(b, b, b), n);\nfloat d4 = dot(vec3(0, a, c), n);\nfloat d5 = dot(vec3(c, 0, a), n);float d = smoothMax(d1, d2, 0.0000 * 0.5);\nd = smoothMax(d, d3, 0.0000 * 0.5);\nd = smoothMax(d, d4, 0.0000 * 0.5);\nd = smoothMax(d, d5, 0.0000 * 0.5);return (d - r) / sqrt(3.0);\n}vec3 getRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getThreeDRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getAdjustedP(vec3 p) {\nfloat scale = max(1.3380, 0.000000001);\nfloat scaleFactor = 1.0/scale;\nvec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 1.24);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 axis = vec2(-1. * vec3(0.5416666666666666, 0.5638888888888889, -0.0702).y - 1. + mousePos.y/PI, vec3(0.5416666666666666, 0.5638888888888889, -0.0702).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02;\nfloat timeX = vec3(0, 1, 0).x * baseTime;\nfloat timeY = vec3(0, 1, 0).y * baseTime;\nfloat timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI);\nmat3 rotXMat = rotX(axis.x * PI);\nmat3 rotZMat = rotZ(vec3(0.5416666666666666, 0.5638888888888889, -0.0702).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;\nmat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP;\nadjustedP = combinedAnimation * adjustedP;\nadjustedP = getThreeDRepeat(adjustedP);\nadjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y)));\nadjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP;\n}float getMergedSDF(vec3 p) {\np = getAdjustedP(p);\nreturn sdDodecahedron(p, 1.);\n}float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {\nfloat NdotV = abs(dot(eyeVector, worldNormal));\nfloat width = fwidth(dot(eyeVector, worldNormal));\nfloat threshold = 0.2;\nfloat edgeDampFactor = smoothstep(threshold, -threshold, width);\nfloat fresnelFactor = 1.0 - NdotV;\nreturn pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5);\n}vec3 noFrostOrDispersion(vec3 rd, vec3 normal) {\nfloat ior = 1.0 / (1.0 + 0.5000 * 0.25);\nvec3 refractedRay = refract(rd, normal, ior);\nreturn texture(uTexture, vTextureCoord - refractedRay.xy).rgb;\n}vec3 frostOrDispersion(vec3 rd, vec3 normal) {\nvec3 refractionColor = vec3(0);\nfloat iorBase = 1. + 0.5000 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.2500 * 1.2;for (int i = 0; i < DISP_STEPS; ++i) {\nfloat step = float(i) / float(DISP_STEPS);\nvec3 disp = step * dispCoefficients;\nvec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r);\nvec3 refractedRayG = refract(rd, normal, ior.g);\nvec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r;\nrefractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g;\nrefractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b;\n}return clamp(refractionColor / float(DISP_STEPS), 0.0, 1.0);\n}vec3 calculateNormal(vec3 p, float eps) {\nvec2 e = vec2(1.0, -1.0) * eps * 0.5;\nreturn normalize(\ne.xyy * getMergedSDF(p + e.xyy) +\ne.yyx * getMergedSDF(p + e.yyx) +\ne.yxy * getMergedSDF(p + e.yxy) +\ne.xxx * getMergedSDF(p + e.xxx)\n);\n}vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);\nreturn noFrostOrDispersion(rd, normal);\n}float scene(vec3 p) {\nreturn max(0.0000000001, getMergedSDF(p) - (0.0000 + 0.005)) * max(1.3380, 0.000000001);\n}const int STEPS = 128;\nconst float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) {\nfloat pixelSize = 0.0025;\nfloat traveled = 0.;\nvec3 entryPoint = vec3(0.0);\nvec3 entryNormal = vec3(0.0);\nfloat partialAlpha = 0.0;\nfloat lastDistance = 0.0;\nfloat smoothing = mix(1., 4., 1.0000);for (int i = 0; i < STEPS; ++i) {\nvec3 currentPos = ro + rd * traveled;\nfloat distance = scene(currentPos);\nfloat progress = float(i)/float(STEPS);\nfloat step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) {\npartialAlpha = 1.;\nentryPoint = currentPos;\nentryNormal = calculateNormal(entryPoint, pixelSize * smoothing);\nbreak;\n}lastDistance = distance;traveled += max(step, pixelSize);\nif (traveled > MAX_DISTANCE) break;\n}if (partialAlpha == 0.0) {\nreturn texture(uTexture, vTextureCoord);\n}vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = texture(uTexture, vTextureCoord).rgb;refractionColor = sampleTexture(samplePosition, entryNormal);\nvec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5321095666699623, 0.5849442614770538), vec3(0.25, 0.25, -3).z);\nvec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir);\nvec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000);\nvec3 fresnelEffect = vec3(0.0);fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.5000 * vec3(1, 1, 1);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd);\nfloat specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.5000 + 0.01);\nspecularEffect = specFactor * 0.5000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect;\nvec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000);\nfinalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor;\n}out vec4 fragColor;void main() {\nvec4 col = vec4(0);\nvec4 bg = texture(uTexture, vTextureCoord);if(1.3380 <= 0.0001 || 1.0000 <= 0.0001) {\ncol = vec4(0);\nif(1 == 1) {\ncol = bg;\n}\nfragColor = col;\nreturn;\n}vec2 pos = vec2(0.5321095666699623, 0.5849442614770538) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 uv = vTextureCoord - pos;\nfloat fovFactor = tan(radians(20.) * 0.5);\nvec3 rd = vec3(uv * fovFactor, 0.5);\ncol = rayMarch(viewDir, rd);\nfloat dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0;\ncol += dither;col = mix(bg, col, 1.0000);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.5000, 1.0 - 0.5000);\nfloat halfRadius = 0.9700 * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.4794049564725485, 0.5079084967145414);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(-0.0081 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(-0.0081 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;finalColor = mix(bg.rgb, mix(bg.rgb, vec3(0, 0, 0), 1.0000), falloff);float alpha = max(bg.a, falloff * 1.0000);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"bokeh","usesPingPong":false,"trackMouse":0.27,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uBlueNoise;uniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t * t * t;\n}const float PI = 3.14159265;\nconst float PI2 = 6.28318530718;\nconst int SAMPLES = 128;vec2 getDiskSample(int index) {\nswitch(index) {\ncase 0: return vec2(0, 0);\ncase 1: return vec2(0.7062550187110901, 0.03469608351588249);\ncase 2: return vec2(0.49759235978126526, 0.0490085706114769);\ncase 3: return vec2(0.8566519618034363, 0.1270723193883896);\ncase 4: return vec2(0.34675997495651245, 0.06897484511137009);\ncase 5: return vec2(0.7668770551681519, 0.19209270179271698);\ncase 6: return vec2(0.5860038995742798, 0.17776232957839966);\ncase 7: return vec2(0.880733847618103, 0.31513160467147827);\ncase 8: return vec2(0.2309698760509491, 0.09567085653543472);\ncase 9: return vec2(0.6779919862747192, 0.3206663131713867);\ncase 10: return vec2(0.49300897121429443, 0.2635187804698944);\ncase 11: return vec2(0.7731460928916931, 0.46340593695640564);\ncase 12: return vec2(0.3600369095802307, 0.24056896567344666);\ncase 13: return vec2(0.6659845113754272, 0.4939277768135071);\ncase 14: return vec2(0.5112983584403992, 0.41961172223091125);\ncase 15: return vec2(0.7174228429794312, 0.6502341628074646);\ncase 16: return vec2(0.125, 0.125);\ncase 17: return vec2(0.4894784986972809, 0.5400562882423401);\ncase 18: return vec2(0.336437851190567, 0.40995070338249207);\ncase 19: return vec2(0.5265287756919861, 0.7099418640136719);\ncase 20: return vec2(0.21960841119289398, 0.32866722345352173);\ncase 21: return vec2(0.41647082567214966, 0.694839596748352);\ncase 22: return vec2(0.3004576563835144, 0.5621167421340942);\ncase 23: return vec2(0.40702033042907715, 0.8605721592903137);\ncase 24: return vec2(0.11717239022254944, 0.28287917375564575);\ncase 25: return vec2(0.25959107279777527, 0.725508451461792);\ncase 26: return vec2(0.17019447684288025, 0.5610560178756714);\ncase 27: return vec2(0.2231915444135666, 0.8910306096076965);\ncase 28: return vec2(0.0912451446056366, 0.45872029662132263);\ncase 29: return vec2(0.12439680844545364, 0.8386151790618896);\ncase 30: return vec2(0.06710775196552277, 0.6813564300537109);\ncase 31: return vec2(0.048294905573129654, 0.9830654263496399);\ncase 32: return vec2(7.654042828657299e-18, 0.125);\ncase 33: return vec2(-0.03523404151201248, 0.7172054052352905);\ncase 34: return vec2(-0.05051687732338905, 0.5129064917564392);\ncase 35: return vec2(-0.1283891648054123, 0.8655294179916382);\ncase 36: return vec2(-0.0731588676571846, 0.3677944839000702);\ncase 37: return vec2(-0.19447903335094452, 0.7764038443565369);\ncase 38: return vec2(-0.18142792582511902, 0.598087728023529);\ncase 39: return vec2(-0.3179328143596649, 0.8885627388954163);\ncase 40: return vec2(-0.10696326941251755, 0.2582321763038635);\ncase 41: return vec2(-0.3250895142555237, 0.6873440146446228);\ncase 42: return vec2(-0.27002641558647156, 0.5051838755607605);\ncase 43: return vec2(-0.4678405523300171, 0.7805448174476624);\ncase 44: return vec2(-0.2503921091556549, 0.37473827600479126);\ncase 45: return vec2(-0.4995090663433075, 0.6735100150108337);\ncase 46: return vec2(-0.4270390570163727, 0.5203486084938049);\ncase 47: return vec2(-0.6556304097175598, 0.7233766317367554);\ncase 48: return vec2(-0.1530931144952774, 0.1530931144952774);\ncase 49: return vec2(-0.547940731048584, 0.49662455916404724);\ncase 50: return vec2(-0.4211843013763428, 0.34565702080726624);\ncase 51: return vec2(-0.7170061469078064, 0.5317679643630981);\ncase 52: return vec2(-0.3447090983390808, 0.23032724857330322);\ncase 53: return vec2(-0.7030628323554993, 0.42139965295791626);\ncase 54: return vec2(-0.5728246569633484, 0.3061811625957489);\ncase 55: return vec2(-0.867959201335907, 0.41051411628723145);\ncase 56: return vec2(-0.3055444359779358, 0.12656064331531525);\ncase 57: return vec2(-0.7349926233291626, 0.2629845440387726);\ncase 58: return vec2(-0.5736655592918396, 0.17401954531669617);\ncase 59: return vec2(-0.8992430567741394, 0.22524864971637726);\ncase 60: return vec2(-0.47482064366340637, 0.09444769471883774);\ncase 61: return vec2(-0.8476815819740295, 0.12574167549610138);\ncase 62: return vec2(-0.692619264125824, 0.06821703910827637);\ncase 63: return vec2(-0.9909616708755493, 0.04868282377719879);\ncase 64: return vec2(-0.0883883461356163, 1.0824450754283193e-17);\ncase 65: return vec2(-0.7117512822151184, -0.03496609628200531);\ncase 66: return vec2(-0.5053074359893799, -0.04976843670010567);\ncase 67: return vec2(-0.8611021637916565, -0.12773244082927704);\ncase 68: return vec2(-0.35743197798728943, -0.07109764218330383);\ncase 69: return vec2(-0.7716551423072815, -0.19328954815864563);\ncase 70: return vec2(-0.5920765995979309, -0.17960448563098907);\ncase 71: return vec2(-0.8846569657325745, -0.3165353238582611);\ncase 72: return vec2(-0.2449805587530136, -0.10147427022457123);\ncase 73: return vec2(-0.6826840043067932, -0.3228854835033417);\ncase 74: return vec2(-0.49913355708122253, -0.2667924463748932);\ncase 75: return vec2(-0.7768542766571045, -0.4656285345554352);\ncase 76: return vec2(-0.36746111512184143, -0.2455296814441681);\ncase 77: return vec2(-0.6697578430175781, -0.49672624468803406);\ncase 78: return vec2(-0.5158433318138123, -0.42334166169166565);\ncase 79: return vec2(-0.7204058766365051, -0.6529378294944763);\ncase 80: return vec2(-0.1397542506456375, -0.1397542506456375);\ncase 81: return vec2(-0.4930644631385803, -0.5440127849578857);\ncase 82: return vec2(-0.34107857942581177, -0.41560545563697815);\ncase 83: return vec2(-0.529154896736145, -0.7134827375411987);\ncase 84: return vec2(-0.22503165900707245, -0.33678367733955383);\ncase 85: return vec2(-0.41894248127937317, -0.6989632844924927);\ncase 86: return vec2(-0.3033328950405121, -0.5674959421157837);\ncase 87: return vec2(-0.40877094864845276, -0.8642735481262207);\ncase 88: return vec2(-0.12195689231157303, -0.2944299876689911);\ncase 89: return vec2(-0.26129332184791565, -0.7302659153938293);\ncase 90: return vec2(-0.17211763560771942, -0.567395806312561);\ncase 91: return vec2(-0.22422246634960175, -0.8951462507247925);\ncase 92: return vec2(-0.09286022931337357, -0.46683987975120544);\ncase 93: return vec2(-0.12507104873657227, -0.8431605696678162);\ncase 94: return vec2(-0.06766466796398163, -0.6870108842849731);\ncase 95: return vec2(-0.04848925396800041, -0.9870214462280273);\ncase 96: return vec2(-2.81227478546514e-17, -0.1530931144952774);\ncase 97: return vec2(0.03549996390938759, -0.7226183414459229);\ncase 98: return vec2(0.05125438794493675, -0.5203945636749268);\ncase 99: return vec2(0.12904255092144012, -0.8699342012405396);\ncase 100: return vec2(0.0751635953783989, -0.37787291407585144);\ncase 101: return vec2(0.1956612914800644, -0.7811236381530762);\ncase 102: return vec2(0.18323321640491486, -0.6040389537811279);\ncase 103: return vec2(0.31932422518730164, -0.8924514055252075);\ncase 104: return vec2(0.11218402534723282, -0.27083620429039);\ncase 105: return vec2(0.3272787034511566, -0.6919726729393005);\ncase 106: return vec2(0.27322208881378174, -0.5111625790596008);\ncase 107: return vec2(0.4700421690940857, -0.7842180132865906);\ncase 108: return vec2(0.25516191124916077, -0.38187679648399353);\ncase 109: return vec2(0.5022764205932617, -0.6772413849830627);\ncase 110: return vec2(0.43070468306541443, -0.5248152017593384);\ncase 111: return vec2(0.6583119034767151, -0.7263352870941162);\ncase 112: return vec2(0.16535945236682892, -0.16535945236682892);\ncase 113: return vec2(0.5518407225608826, -0.5001592636108398);\ncase 114: return vec2(0.4266902208328247, -0.3501756191253662);\ncase 115: return vec2(0.720512330532074, -0.5343683362007141);\ncase 116: return vec2(0.35245633125305176, -0.23550379276275635);\ncase 117: return vec2(0.7071385979652405, -0.42384254932403564);\ncase 118: return vec2(0.5781042575836182, -0.30900317430496216);\ncase 119: return vec2(0.8716292381286621, -0.41224992275238037);\ncase 120: return vec2(0.31626853346824646, -0.13100272417068481);\ncase 121: return vec2(0.7396891117095947, -0.26466497778892517);\ncase 122: return vec2(0.5798675417900085, -0.1759008914232254);\ncase 123: return vec2(0.9033212661743164, -0.22627019882202148);\ncase 124: return vec2(0.4826694428920746, -0.09600891917943954);\ncase 125: return vec2(0.8521785736083984, -0.12640875577926636);\ncase 126: return vec2(0.6981825828552246, -0.06876497715711594);\ncase 127: return vec2(0.9948862791061401, -0.04887562617659569);\ndefault: return vec2(0.0);\n}\n}float getBlueNoiseOffset(vec2 st) {\nivec2 texSize = ivec2(512, 512);\nvec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);\nreturn mod((blueNoise.r - 0.5) * PI2, PI2);\n}vec4 bokehBlur(vec2 uv, float blurRadius, float intensity) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec3 accumulatedColor = vec3(0.0);\nvec3 accumulatedWeights = vec3(0.0);\nvec2 pixelSize = vec2(1.0 / aspectRatio, 1.0) * blurRadius * 0.075;\nfloat accumulatedAlpha = 0.;\nfloat noiseOffset = (getBlueNoiseOffset(uv) - 0.5) * 0.1;\nfloat noiseAngle = noiseOffset * PI2;\nmat2 rotationMatrix = mat2(\ncos(noiseAngle), -sin(noiseAngle),\nsin(noiseAngle), cos(noiseAngle)\n);for (int i = 0; i < 128; i++) {\nvec2 sampleOffset = rotationMatrix * getDiskSample(i) * pixelSize;\nfloat jitterAmount = 0.05 * (sin(float(i) * 0.1) * 0.5 + 0.5);\nsampleOffset *= 1.0 + jitterAmount * sin(float(i) * 0.7 + noiseOffset);\nvec4 colorSample = texture(uTexture, uv + sampleOffset);\nvec3 bokehWeight = vec3(5.0) + pow(colorSample.rgb, vec3(9.0)) * intensity;\naccumulatedAlpha += colorSample.a;accumulatedColor += colorSample.rgb * bokehWeight;\naccumulatedWeights += bokehWeight;\n}return vec4(accumulatedColor / accumulatedWeights, accumulatedAlpha / 128.0);\n}out vec4 fragColor;vec4 blurPass(vec2 uv) {\nvec2 pos = vec2(0.4719907408026659, 0.4894553377139448) + mix(vec2(0), (uMousePos-0.5), 0.2700);\nfloat dis = distance(uv, pos) * 1000.;\nfloat tilt = mix(1.-dis * 0.001 , dis * 0.001, 0.1600);\nreturn bokehBlur(uv, 0.3700 * ease(4, tilt), 150.0);\n}vec4 getColor(vec2 uv) {\nreturn blurPass(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);if(0.3700 == 0.) {\ncolor = texture(uTexture, uv);\nfragColor = color;return;\n}\ncolor = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform sampler2D uBlueNoise;uniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t * t * t;\n}const float PI = 3.14159265;\nconst float PI2 = 6.28318530718;\nconst int SAMPLES = 128;float getBlueNoiseOffset(vec2 st) {\nivec2 texSize = ivec2(512, 512);\nvec4 blueNoise = texelFetch(uBlueNoise, ivec2(fract(st * (uResolution)/vec2(texSize) * vec2(texSize.x/texSize.y, 1.0)) * vec2(texSize)) % texSize, 0);\nreturn mod((blueNoise.r - 0.5) * PI2, PI2);\n}out vec4 fragColor;vec4 composite(vec2 uv) {\nvec4 color = vec4(0.);\nvec2 pos = vec2(0.4719907408026659, 0.4894553377139448) + mix(vec2(0), (uMousePos-0.5), 0.2700);\nfloat dis = distance(uv, pos) * 1000.;\nfloat tilt = mix(1.-dis * 0.001 , dis * 0.001, 0.1600);\nfloat strength = ease(4, tilt);\nvec4 bg = texture(uBgTexture, uv);if(0.3700 <= 0.001) {\nreturn bg;\n}if(strength <= 0.002) {\nreturn bg;\n}\nfloat blueNoiseOffset = getBlueNoiseOffset(uv);\nfloat blueNoiseStrength = 0.005 * 0.3700 * strength;\nvec2 offset = vec2(cos(blueNoiseOffset), sin(blueNoiseOffset)) * min(blueNoiseStrength, 0.01);\nreturn texture(uTexture, uv + offset);\n}vec4 getColor(vec2 uv) {\nreturn composite(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = vec4(0);if(0.3700 == 0.) {\ncolor = texture(uTexture, uv);\nfragColor = color;return;\n}\ncolor = getColor(uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"includeBg":true}],"texture":{"src":"https://assets.unicorn.studio/media/blue_noise_med.png","sampler":"uBlueNoise"}},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"grain","usesPingPong":false,"speed":0.26,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn min(src, dst);\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);if(color.a <= 0.001) {\nfragColor = vec4(0);\nreturn;\n}vec2 st = uv;\nvec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(0 == 1) {\ngrainRGB = vec3(\nrandFibo(st + vec2(1, 2) + delta),\nrandFibo(st + vec2(2, 3) + delta),\nrandFibo(st + vec2(3, 4) + delta)\n);\n} else {\ngrainRGB = vec3(randFibo(st + vec2(delta)));\n}\ncolor.rgb = mix(color.rgb, blend(6, grainRGB, color.rgb), 0.0900);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect5"}],"options":{"name":"Bokeh Gradient Shape Stack (Remix) (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.0","id":"rbXkMcpghjdhYz0I2sIv"}
