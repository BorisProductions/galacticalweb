{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.59,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0, 0, 0); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"aurora","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/images/kGMzc0o7IjS5OYNmrwXUycPItB12/remix_Vector_combined_1757156882690.png","sampler":"uCustomTexture"},"speed":0.64,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uCustomTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; } uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); }out vec4 fragColor;ivec2 customTexSize; float customTexAspect;const float PI = 3.14159265359; const float TAU = 6.28318530718;vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return a + b*cos( TAU*(c*t+d) ); }vec3 Tonemap_Reinhard(vec3 x) { x *= 4.; return x / (1.0 + x); }float sdLine(vec2 p, float r) { float halfLen = r * 2.; vec2 a = vec2(-halfLen, 0.0); vec2 b = vec2(halfLen, 0.0); vec2 pa = p - a; vec2 ba = b - a; float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0); return length(pa - ba * h); }float getSdf(vec2 st, float iter, float md) { return sdLine(st, 0.5040); }vec2 turb(vec2 pos, float t, float it, float md, vec2 mPos) { mat2 rot = mat2(0.6, -0.8, 0.8, 0.6); float freq = mix(2., 15., 0.0000); float amp = (0.0000) * md; float xp = 1.4; float time = t * 0.1 + 0.3100; for(float i = 0.; i < 4.; i++) { vec2 s = sin(freq * ((pos - mPos) * rot) + i * time + it); pos += amp * rot[0] * s / freq; rot *= mat2(0.6, -0.8, 0.8, 0.6); amp *= mix(1., max(s.y, s.x), 0.0000); freq *= xp; }return pos; }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }const float ITERATIONS = 36.;void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);if(3 == 0) { customTexSize = textureSize(uCustomTexture, 0); customTexAspect = float(customTexSize.x) / float(customTexSize.y); } vec3 pp = vec3(0.); vec3 bloom = vec3(0.); float t = uTime * 0.5 + 0.3100; vec2 aspect = vec2(uResolution.x/uResolution.y, 1); vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000); vec2 pos = (uv * aspect - vec2(0.5044886877828054, 0.5223385735493824) * aspect); float mDist = length(uv * aspect - uMousePos * aspect); float md = mix(1., smoothstep(1., 5., 1./mDist), 1.0000); float rotation = -0.0054 * -2.0 * 3.14159265359; mat2 rotMatrix = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation)); pos = rotMatrix * pos; float bm = 0.05; vec2 prevPos = turb(pos, t, 0. - 1./ITERATIONS, md, mousePos); float spacing = mix(1., TAU, 0.0000); float smoothing = 0.3700; for(float i = 1.; i < ITERATIONS + 1.; i++) { float iter = i/ITERATIONS; vec2 st = turb(pos, t, iter * spacing, md, mousePos); float d = abs(getSdf(st, iter, md)); float pd = distance(st, prevPos); prevPos = st; float dynamicBlur = exp2(pd * 2.0 * 1.4426950408889634) - 1.0; float ds = smoothstep(0., 0.7200 * bm + max(dynamicBlur * smoothing, 0.001), d); vec3 color = pal(iter * mix(0.1, 1.9, 1.0000) + 0.4200, vec3(0.5), vec3(0.5), vec3(1), vec3(1, 1, 1)); float invd = 1./max(d + dynamicBlur, 0.001); pp += (ds - 1.) * color; bloom += clamp(invd, 0., 250.) * color; }pp *= 1./ITERATIONS; bloom = bloom / (bloom + 2e4);vec3 color = (-pp + bloom * 3. * 1.0000); color *= 1.2; color += (randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color = (Tonemap_Reinhard(color)); vec4 auroraColor = vec4(color, 1.); auroraColor.rgb = blend(1, bg.rgb, auroraColor.rgb);auroraColor = vec4(mix(bg.rgb, auroraColor.rgb, 1.0000), max(bg.a, luma(auroraColor.rgb))); fragColor = auroraColor;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"coloration","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;vec3 getFilteredColor(vec3 color) { return color; }float hueToRgb(float p, float q, float t) { if (t < 0.0) t += 1.0; if (t > 1.0) t -= 1.0; if (t < 1.0 / 6.0) return p + (q - p) * 6.0 * t; if (t < 1.0 / 2.0) return q; if (t < 2.0 / 3.0) return p + (q - p) * (2.0 / 3.0 - t) * 6.0; return p; }vec3 hslToRgb(vec3 hsl) { float h = hsl.x; float s = hsl.y; float l = hsl.z; vec3 rgb = vec3(l); if (s != 0.0) { float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s; float p = 2.0 * l - q; rgb.r = hueToRgb(p, q, h + 1.0 / 3.0); rgb.g = hueToRgb(p, q, h); rgb.b = hueToRgb(p, q, h - 1.0 / 3.0); } return rgb; }vec3 rgbToHsl(vec3 rgb) { float max = max(max(rgb.r, rgb.g), rgb.b); float min = min(min(rgb.r, rgb.g), rgb.b); float h, s, l = (max + min) / 2.0;if (max == min) { h = s = 0.0; } else { float d = max - min; s = l > 0.5 ? d / (2.0 - max - min) : d / (max + min); if (max == rgb.r) { h = (rgb.g - rgb.b) / d + (rgb.g < rgb.b ? 6.0 : 0.0); } else if (max == rgb.g) { h = (rgb.b - rgb.r) / d + 2.0; } else if (max == rgb.b) { h = (rgb.r - rgb.g) / d + 4.0; } h /= 6.0; }return vec3(h, s, l); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(color.a <= 0.001) { fragColor = vec4(0); return; }color.rgb = rgbToHsl(color.rgb); color.x = fract(color.x + 1.0000); color.y = clamp(color.y * 0.0000, 0.0, 1.0); color.z = clamp(color.z + 0.2300, 0.0, 1.0); color.rgb = hslToRgb(color.rgb); if(1 > 0) { color.rgb = getFilteredColor(color.rgb); } color.rgb = 2.0000 * (color.rgb - 0.5) + 0.5; color.r = clamp(color.r + 0.0000, 0.0, 1.0); color.b = clamp(color.b - 0.0000, 0.0, 1.0);color = vec4(clamp(color.rgb, 0.0, 1.0), color.a); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sine","usesPingPong":false,"speed":0.1,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord; in vec3 vVertexPosition; uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } out vec4 fragColor;const float PI = 3.141592;void main() { vec2 uv = vTextureCoord; vec2 waveCoord = vTextureCoord.xy * 2.0 - 1.0; float thirdPI = PI * 0.3333; float time = uTime * 0.25; float frequency = 20.0 * 0.2780; float amp = 1.0000 * 0.2;float waveX = sin((waveCoord.y + vec2(0.5, 0.5).y) * frequency + (time * thirdPI)) * amp; float waveY = sin((waveCoord.x - vec2(0.5, 0.5).x) * frequency + (time * thirdPI)) * amp; waveCoord.xy += vec2(mix(waveX, 0., 1.0000), mix(0., waveY, 1.0000));vec2 finalUV = waveCoord * 0.5 + 0.5; float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(0.8400)); float dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.8400)));if (0 == 1) { dist = max(0., (0.5 - dist)); } uv = mix(uv, finalUV, dist);vec4 color = texture(uTexture, uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"texturize","usesPingPong":false,"speed":0,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uvec2 pcg2d(uvec2 v) { v = v * 1664525u + 1013904223u; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; v ^= v >> 16; v.x += v.y * v.y * 1664525u + 1013904223u; v.y += v.x * v.x * 1664525u + 1013904223u; return v; }float randFibo(vec2 p) { uvec2 v = floatBitsToUint(p); v = pcg2d(v); uint r = v.x ^ v.y; return float(r) / float(0xffffffffu); } out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float timeRand1 = randFibo(vec2(floor(uTime * 0.5) * 2. + 0.001, 0.5)); float timeRand2 = randFibo(vec2(floor(uTime * 0.5) * 2. + 1.001, 0.5)); float sizeX = 0.0100 * 0.2 * timeRand1; float sizeY = 0.0100 * 0.2 * timeRand2; float floorY = floor(uv.y/sizeY) + 0.005; float floorX = floor(uv.x/sizeX) + 0.005; float phase = 0.0100 * 0.01; float chromab = 0.0000 * 0.75; float offset = 0.;vec2 blockSize = vec2(50.0, 50.0) * (1.0 - 0.0100); vec2 blockUV = floor(uv * blockSize) / blockSize; float blockRand = randFibo(blockUV); float blockTimeRand = timeRand1; float blockNoise = mix( 1., step(0.8, randFibo(vec2(blockTimeRand, blockRand))), 0.0000 );float offsetX = 0.2300 * 0.5 * blockNoise; float offsetY = 0.7200 * 0.5 * blockNoise;float randY = randFibo(vec2(sin(floorY + offset + phase), 0.5)); float randX = randFibo(vec2(cos(floorX + offset + phase), 0.5)); float glitchModX = max(0.005, sign(randY - 0.5 - (1. - 1.0000*2.)/2.)); float glitchModY = max(0.005, sign(randX - 0.5 - (1. - 1.0000*2.)/2.));float randOffX = randFibo(vec2(floorY + offset * glitchModX + phase, 0.7)); float randOffY = randFibo(vec2(floorX + offset * glitchModY + phase, 0.9)); float offX = (randOffX * offsetX - offsetX/2.)/5.; float offY = (randOffY * offsetY - offsetY/2.)/5.;offX = clamp(offX, -1.0, 1.0); offY = clamp(offY, -1.0, 1.0);uv.x = mix(uv.x, uv.x + offX * 2., glitchModX); uv.y = mix(uv.y, uv.y + offY * 2., glitchModY);float waveFreq = 30.0; float waveAmp = 0.005 * 0.0000; float timeOffset = uTime * 0.05; float sinY = sin((uv.y + 0.0100) * waveFreq * (1. - 0.0100) * 2. + timeOffset); float rogue = smoothstep(0., 2., sinY - 0.5) * 0.2 * 0.0000; float sinWaveX = sin(uv.y * waveFreq + uTime); float sinWaveY = sin(uv.x * waveFreq + uTime); uv.x += sinWaveX * waveAmp + rogue; uv.y += sinWaveY * waveAmp; float waveX = sinWaveX * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.005), vec2(0.995));vec4 color = texture(uTexture, uv);vec2 redOffset = vec2( clamp(uv.x + (glitchModX * -offX * chromab - waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * -offY * chromab), 0.005, 0.995) ); vec2 blueOffset = vec2( clamp(uv.x + (glitchModX * offX * chromab + waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * offY * chromab), 0.005, 0.995) );color.r = texture(uTexture, redOffset).r; color.b = texture(uTexture, blueOffset).b; fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"},{"breakpoints":[{"props":{"texture":["https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/8oFmEoSE8vdRMSnWgq60c72sHkm1%2FSP4_Artboard%201_v1_%40thumbnail.png?alt=media&token=c2ec174a-f771-479f-a485-d455dde5a160","https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/8oFmEoSE8vdRMSnWgq60c72sHkm1%2FSP4_Artboard%201_v1.png?alt=media&token=c2ec174a-f771-479f-a485-d455dde5a160","uCustomTexture","SP4_Artboard 1_v1.png"],"glyphSet":"4"},"name":"Desktop","min":992,"max":null},{"max":575,"props":{"glyphSet":"5","texture":["uCustomTexture","https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/8oFmEoSE8vdRMSnWgq60c72sHkm1%2FSP5_Artboard%201_v1_%40thumbnail.png?alt=media&token=063285ea-1827-49e4-83ca-5840ffce6fed","SP5_Artboard 1_v1.png","https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/8oFmEoSE8vdRMSnWgq60c72sHkm1%2FSP5_Artboard%201_v1.png?alt=media&token=063285ea-1827-49e4-83ca-5840ffce6fed"]},"min":0,"name":"Mobile"}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"ascii","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/images/kGMzc0o7IjS5OYNmrwXUycPItB12/remix_SP5_Artboard 1_v1.png","sampler":"uCustomTexture"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"states":{"appear":[],"scroll":[],"hover":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"hover","id":"f04d3082-ef65-44e9-90f7-d6f68738cd99","prop":"texture","transition":{"delay":0,"ease":"easeInOutQuart","duration":1000},"progress":0,"rawProgress":0,"lastProgress":null,"value":{"name":"SP5_Artboard 1_v1.png","thumb":"https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/8oFmEoSE8vdRMSnWgq60c72sHkm1%2FSP5_Artboard%201_v1_%40thumbnail.png?alt=media&token=063285ea-1827-49e4-83ca-5840ffce6fed","src":"https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/8oFmEoSE8vdRMSnWgq60c72sHkm1%2FSP5_Artboard%201_v1.png?alt=media&token=063285ea-1827-49e4-83ca-5840ffce6fed","sampler":"uCustomTexture"},"triggerOnElement":1,"breakpoints":[]}]},"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform sampler2D uSprite; uniform sampler2D uCustomTexture; uniform int uGlyph;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src; }out vec4 fragColor;const float GLYPH_HEIGHT = 40.0; const float DEFAULT_NUM_SPRITES = 10.0; const float DEFAULT_NUM_ROWS = 6.0;void main() { vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); float aspectRatio = uResolution.x / uResolution.y; float aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = (0.1200 + 0.01) * 0.05;float baseGrid = 1.0 / gridSize; vec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection; vec2 offsetUv = uv - pos; vec2 cell = floor(offsetUv / cellSize); vec2 cellCenter = (cell + 0.5) * cellSize; vec2 pixelatedCoord = cellCenter + pos; vec4 bg = texture(uTexture, vTextureCoord); vec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722)); luminance = mix(luminance, 1.0 - luminance, float(0)); float gamma = mix(0.0, 4.0, 0.2500); luminance = pow(luminance, gamma);float scaleFactor = gridSize / GLYPH_HEIGHT;ivec2 customTextureSize = textureSize(uCustomTexture, 0); float customSpriteWidth = float(customTextureSize.x); float numSprites = mix(DEFAULT_NUM_SPRITES, customSpriteWidth / GLYPH_HEIGHT, float(uGlyph == 6)); float numGlyphRows = mix(DEFAULT_NUM_ROWS, 1.0, float(uGlyph == 6));float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0); float glyphIndex = mix(5.0 - float(uGlyph), 0.0, float(uGlyph == 6));float normalizedSpriteSizeX = 1.0 / numSprites; float normalizedSpriteSizeY = 1.0 / numGlyphRows;vec2 spriteSheetUV = vec2( spriteIndex * normalizedSpriteSizeX, glyphIndex / numGlyphRows );vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection; vec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;spriteSheetUV += vec2( localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY );vec4 spriteColor = vec4(0.0); if(uGlyph == 6) { spriteColor = texture(uCustomTexture, spriteSheetUV); } else { spriteColor = texture(uSprite, spriteSheetUV); } float alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4; vec3 col = mix(cc, vec3(0, 1, 1), float(0)); vec3 dithered = mix( mix(vec3(0.0), vec3(1.0), float(0)), col, alpha ); vec3 blended = blend(0, dithered, bg.rgb); color.rgb = mix(bg.rgb, blended, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"glyphSet":{"name":"uGlyph","type":"1i","value":0}},"isBackground":false,"texture":{"src":"https://assets.unicorn.studio/media/ascii_spritesheet_larger.png","sampler":"uSprite"}},"id":"effect5"}],"options":{"name":"Startale Wave 02 (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.4.31","id":"lkRbw0syJAmLYZg6nkzl"}
