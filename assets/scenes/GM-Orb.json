{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0.25882352941176473, 0, 0.5176470588235295);\ncase 2: return vec3(0.5019607843137255, 0, 1);\ncase 3: return vec3(0.5294117647058824, 0.07058823529411765, 1);\ncase 4: return vec3(0.6470588235294118, 0.47843137254901963, 1);\ncase 5: return vec3(0.9882352941176471, 0.9176470588235294, 1);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.6500*2.);\nuv = rotate(uv, (0.6561 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"aurora","usesPingPong":false,"texture":false,"speed":0.25,"trackMouse":0.27,"trackAxes":"xy","mouseMomentum":1.55,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;ivec2 customTexSize;\nfloat customTexAspect;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\nreturn a + b*cos( TAU*(c*t+d) );\n}vec3 Tonemap_Reinhard(vec3 x) {\nx *= 4.;\nreturn x / (1.0 + x);\n}float sdCircle(vec2 st, float r) {\nreturn length(st) - r;\n}float getSdf(vec2 st, float iter, float md) {\nreturn sdCircle(st, 0.3500);\n}vec2 turb(vec2 pos, float t, float it, float md, vec2 mPos) {\nmat2 rot = mat2(0.6, -0.8, 0.8, 0.6);\nfloat freq = mix(2., 15., 0.7600);\nfloat amp = (0.6200) * md;\nfloat xp = 1.4;\nfloat time = t * 0.1 + 0.0000;\nfor(float i = 0.; i < 4.; i++) {\nvec2 s = sin(freq * ((pos - mPos) * rot) + i * time + it);\npos += amp * rot[0] * s / freq;\nrot *= mat2(0.6, -0.8, 0.8, 0.6);\namp *= mix(1., max(s.y, s.x), 0.0000);\nfreq *= xp;\n}return pos;\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}const float ITERATIONS = 36.;void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nvec3 pp = vec3(0.);\nvec3 bloom = vec3(0.);\nfloat t = uTime * 0.5 + 0.0000;\nvec2 aspect = vec2(uResolution.x/uResolution.y, 1);\nvec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.2700);\nvec2 pos = (uv * aspect - vec2(0.5, 0.5) * aspect);\nfloat mDist = length(uv * aspect - uMousePos * aspect);\nfloat md = mix(1., smoothstep(1., 5., 1./mDist), 0.1700);\nfloat rotation = 0.0000 * -2.0 * 3.14159265359;\nmat2 rotMatrix = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\npos = rotMatrix * pos;\nfloat bm = 0.05;\nvec2 prevPos = turb(pos, t, 0. - 1./ITERATIONS, md, mousePos);\nfloat spacing = mix(1., TAU, 0.5000);\nfloat smoothing = 1.0000;\nfor(float i = 1.; i < ITERATIONS + 1.; i++) {\nfloat iter = i/ITERATIONS;\nvec2 st = turb(pos, t, iter * spacing, md, mousePos);\nfloat d = abs(getSdf(st, iter, md));\nfloat pd = distance(st, prevPos);\nprevPos = st;\nfloat dynamicBlur = exp2(pd * 2.0 * 1.4426950408889634) - 1.0;\nfloat ds = smoothstep(0., 0.0000 * bm + max(dynamicBlur * smoothing, 0.001), d);\nvec3 color = pal(iter * mix(0.1, 1.9, 0.2500) + 0.8100, vec3(0.5), vec3(0.5), vec3(1), vec3(0.4196078431372549, 0.5843137254901961, 0));\nfloat invd = 1./max(d + dynamicBlur, 0.001);\npp += (ds - 1.) * color;\nbloom += clamp(invd, 0., 250.) * color;\n}pp *= 1./ITERATIONS;\nbloom = bloom / (bloom + 2e4);vec3 color = (-pp + bloom * 3. * 0.7500);\ncolor *= 1.2;\ncolor += (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor = (Tonemap_Reinhard(color));\nvec4 auroraColor = vec4(color, 1.);\nauroraColor.rgb = blend(1, bg.rgb, auroraColor.rgb);\nauroraColor = vec4(mix(bg.rgb, auroraColor.rgb, 1.0000), max(bg.a, luma(auroraColor.rgb)));\nfragColor = auroraColor;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 drawExpandingRings(vec2 uv, vec2 center, float scale, float angle) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;\nvec2 skew = vec2(0.5000, 1. - 0.5000) * 2.;\nuv = uv * rot(0.0000 * TWO_PI) * skew;\ncenter = center * rot(0.0000 * TWO_PI) * skew;\nfloat modulo = fract(uTime * 0.02 + 0.4500);\nfloat ringRadius = scale * 0.5 * modulo;\nfloat distFromCenter = length(uv - center);\nfloat ringDist = abs(distFromCenter - ringRadius);\nfloat lineRadius = 0.0500 * modulo;\nfloat brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));brightness = brightness * max(0., 1.-modulo);vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.00392156862745098, 0.35294117647058826, 0.9176470588235294);\nreturn ringColor;\n}vec3 getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawExpandingRings(uv, pos, 0.8500, 0.0000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, luma(beam)));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 drawExpandingRings(vec2 uv, vec2 center, float scale, float angle) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;\nvec2 skew = vec2(0.5000, 1. - 0.5000) * 2.;\nuv = uv * rot(0.0000 * TWO_PI) * skew;\ncenter = center * rot(0.0000 * TWO_PI) * skew;\nfloat modulo = fract(uTime * 0.02 + 0.3000);\nfloat ringRadius = scale * 0.5 * modulo;\nfloat distFromCenter = length(uv - center);\nfloat ringDist = abs(distFromCenter - ringRadius);\nfloat lineRadius = 0.0500 * modulo;\nfloat brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));brightness = brightness * max(0., 1.-modulo);vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(1, 1, 1);\nreturn ringColor;\n}vec3 getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawExpandingRings(uv, pos, 0.8700, 0.0000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, luma(beam)));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 drawExpandingRings(vec2 uv, vec2 center, float scale, float angle) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;\nvec2 skew = vec2(0.5000, 1. - 0.5000) * 2.;\nuv = uv * rot(0.0000 * TWO_PI) * skew;\ncenter = center * rot(0.0000 * TWO_PI) * skew;\nfloat modulo = fract(uTime * 0.02 + 0.1500);\nfloat ringRadius = scale * 0.5 * modulo;\nfloat distFromCenter = length(uv - center);\nfloat ringDist = abs(distFromCenter - ringRadius);\nfloat lineRadius = 0.0500 * modulo;\nfloat brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));brightness = brightness * max(0., 1.-modulo);vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(1, 1, 1);\nreturn ringColor;\n}vec3 getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawExpandingRings(uv, pos, 0.8900, 0.0000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, luma(beam)));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 drawExpandingRings(vec2 uv, vec2 center, float scale, float angle) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;\nvec2 skew = vec2(0.5000, 1. - 0.5000) * 2.;\nuv = uv * rot(0.0000 * TWO_PI) * skew;\ncenter = center * rot(0.0000 * TWO_PI) * skew;\nfloat modulo = fract(uTime * 0.02 + 0.7900);\nfloat ringRadius = scale * 0.5 * modulo;\nfloat distFromCenter = length(uv - center);\nfloat ringDist = abs(distFromCenter - ringRadius);\nfloat lineRadius = 0.0500 * modulo;\nfloat brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));brightness = brightness * max(0., 1.-modulo);vec3 ringColor = brightness * pow(1.-ringDist, 3.) * vec3(0.21176470588235294, 0, 1);\nreturn ringColor;\n}vec3 getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawExpandingRings(uv, pos, 0.9700, 0.0000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, luma(beam)));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect5"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"liquify","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform float uTime;\nuniform sampler2D uTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t;\n}const float PI = 3.14159265;mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}vec2 liquify(vec2 st, float dist) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.0000);\nvec2 drift = vec2(0, 0.0000 * uTime * 0.0125) * rot(0.0000 * -2. * PI);pos += drift;\nvec2 skew = mix(vec2(1), vec2(1, 0), 0.0000);\nst -= pos;\nst.x *= aspectRatio;\nst = st * rot(0.0000 * 2. * PI);\nst *= skew;\nfloat freq = (5.0 * (0.9100 + 0.1));\nfloat t = uTime * 0.025;float amplitude = 0.4100 * mix(0.2, 0.2/(0.9100 + 0.05), 0.25) * dist;for (float i = 1.0; i <= 5.0; i++) {\nst = st * rot(i / 5. * PI * 2.);\nfloat ff = i * freq;\nst.x += amplitude * cos(ff * st.y + t);\nst.y += amplitude * sin(ff * st.x + t);\n}st /= skew;st = st * rot(0.0000 * -2. * PI);\nst.x /= aspectRatio;\nst += pos;return st;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat dist = ease(0, max(0.,1. - distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 0.3700)));if(dist <= 0.001) {\nfragColor = texture(uTexture, uv);\nreturn;\n}vec2 liquifiedUV = liquify(uv, dist);\nvec2 normalizedUv = normalize(liquifiedUV - uv);\nfloat distanceUv = length(liquifiedUV - uv);\nfloat chromAbb = 0.0100 * 0.5;vec2 offsetR = liquifiedUV + chromAbb * normalizedUv * distanceUv;\nvec2 offsetG = liquifiedUV;\nvec2 offsetB = liquifiedUV - chromAbb * normalizedUv * distanceUv;vec4 colorR = texture(uTexture, mix(uv, offsetR, 2.4700));\nvec4 colorG = texture(uTexture, mix(uv, offsetG, 2.4700));\nvec4 colorB = texture(uTexture, mix(uv, offsetB, 2.4700));vec4 color = vec4(colorR.r, colorG.g, colorB.b, colorR.a * colorG.a * colorB.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect6"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"circle","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}out vec4 fragColor;mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat lum = luma(bg.rgb);\nfloat displacement = (lum - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.5000, 1.0 - 0.5000);\nfloat halfRadius = 0.3500 * 0.5;\nfloat innerEdge = halfRadius - 0.3900 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 0.3900 * halfRadius * 0.5;\nvec2 pos = vec2(0.5, 0.5);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nfalloff = (1.0 - falloff) * 0.5300;\nvec3 circle = vec3(0, 0.08627450980392157, 0.17647058823529413) * falloff;vec3 blended = blend(1, vec3(0, 0.08627450980392157, 0.17647058823529413), bg.rgb);\ncircle = mix(bg.rgb, blended, falloff * 0.5300);\nvec4 color = vec4(circle, max(bg.a, falloff));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect7"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"grain","usesPingPong":false,"speed":0.36,"texture":false,"animating":true,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);if(color.a <= 0.001) {\nfragColor = vec4(0);\nreturn;\n}vec2 st = uv;\nvec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(0 == 1) {\ngrainRGB = vec3(\nrandFibo(st + vec2(1, 2) + delta),\nrandFibo(st + vec2(2, 3) + delta),\nrandFibo(st + vec2(3, 4) + delta)\n);\n} else {\ngrainRGB = vec3(randFibo(st + vec2(delta)));\n}\ncolor.rgb = mix(color.rgb, blend(5, grainRGB, color.rgb), 0.1300);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect8"},{"breakpoints":[],"aspectRatio":1.6,"userDownsample":1,"effects":["ceed68d7-20ab-410e-b0b5-3c00811dbc44"],"anchorPoint":0,"mask":0,"maskDepthLayer":1,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":200,"widthMode":1,"height":200,"heightMode":1,"left":0.15809722222222222,"top":0.18487777777777775,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0.1450980392156863, 0.07450980392156863, 0.5725490196078431);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}uniform vec2 uArtboardResolution;uniform vec2 uMousePos;const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.0, 0.0);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;return getColor(0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);halfSize = uArtboardResolution * 0.5;\np = canvasPosPx - halfSize;\nreturn sdBox(p, halfSize);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = 200.0000;\nfloat absHeight = 200.0000;if (1 == 2) {\nabsWidth = absHeight * 1.6000;\n} else if (1 == 2) {\nabsHeight = absWidth / 1.6000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.1581, 0.1849) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = canvasPosPx;\nvec2 localSize;\nlocalSize = uArtboardResolution;\nvec2 centerPx;\ncenterPx = uArtboardResolution * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getSourceOutput(vec2 uv) {\nreturn sampleShape(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0000;uv -= pos;fragColor = getSourceOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.6}},"compositeShader":{"fragmentShader":"#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uBgTexture;\nuniform sampler2D uTexture;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn max(src, dst);\n}const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(7, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 1.0000);\ncolor = color + background * (1.0 - color.a);\nreturn color;\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0);uv -= pos;vec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}","vertexShader":"#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"},"compositeUniforms":{"resolution":{"name":"uResolution","type":"2f","value":{"type":"Vec2","_x":1080,"_y":1080}},"opacity":{"name":"uOpacity","type":"1f","value":1},"mousePos":{"name":"uMousePos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}}}},"id":"shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sphere","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"ceed68d7-20ab-410e-b0b5-3c00811dbc44","animating":false,"isMask":1,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;const float STEPS = 16.0;\nconst float PI = 3.1415926;vec3 chromaticAbberation(vec2 st, float angle, float amount, float blend) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat rotation = angle * 360.0 * PI / 180.0;\nvec2 aberrated = amount * vec2(0.1 * sin(rotation) * aspectRatio, 0.1 * cos(rotation));\naberrated *= distance(st, vec2(0.5)) * 2.0;\nvec4 red = vec4(0);\nvec4 blue = vec4(0);\nvec4 green = vec4(0);\nfloat invSteps = 1.0 / STEPS;\nfloat invStepsHalf = invSteps * 0.5;\nfor(float i = 1.0; i <= STEPS; i++) {\nvec2 offset = aberrated * (i * invSteps);\nred += texture(uTexture, st - offset) * invSteps;\nblue += texture(uTexture, st + offset) * invSteps;\n}for (float i = 0.0; i <= STEPS; i++) {\nvec2 offset = aberrated * ((i * invSteps) - 0.5);\ngreen += texture(uTexture, st + offset) * invSteps;\n}\nreturn vec3(red.r, green.g, blue.b);\n}vec2 sphericalTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat tau) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nu -= uCenter;\nv -= vCenter;float s = sqrt(u * u + v * v);\nif (s > lensRadius)\nreturn vec2(u + uCenter, v + vCenter);float z = sqrt(lensRadius * lensRadius - s * s);float uAlpha = (1.0 - (1.0 / tau)) * asin(u / lensRadius);\nfloat vAlpha = (1.0 - (1.0 / tau)) * asin(v / lensRadius);u = uCenter + z * sin(uAlpha);\nv = vCenter + z * sin(vAlpha);return vec2(u/aspectRatio, v);\n}float circularIn(float t) {\nreturn 1.0 - sqrt(1.0 - t * t);\n}vec2 fisheyeTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat distortionScale\n) {\nfloat aspectRatio = uResolution.x / uResolution.y;vec2 dir = vec2(u - uCenter, v - vCenter);dir.x /= lensRadius;\ndir.y /= lensRadius;float dist = length(dir) * 0.15;if (dist < 1.0) {\nfloat theta = atan(dir.y, dir.x);float r = dist * 2.0 * PI;\nfloat z = sqrt(1.0 - r * r) + 0.25;\nfloat rDist = atan(r, z) / PI;\nfloat newDist = mix(dist, rDist, 5.);dir.x = newDist * cos(theta);\ndir.y = newDist * sin(theta);\n}dir.x *= lensRadius;\ndir.y *= lensRadius;return mix(vec2(u/aspectRatio, v), vec2(uCenter/aspectRatio, vCenter) + dir, 0.9500);\n}vec2 discTransformation(\nfloat u,\nfloat v,\nfloat uCenter,\nfloat vCenter,\nfloat lensRadius,\nfloat distortionScale) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nu -= uCenter;\nv -= vCenter;float s = sqrt(u * u + v * v);\nif (s > lensRadius)\nreturn vec2(u + uCenter, v + vCenter);\nfloat r = sqrt(u * u + v * v) / lensRadius;\nif(r == 0.0)\nreturn vec2(uCenter, vCenter);r = pow(r, distortionScale);\nfloat theta = atan(r);\nfloat rad = theta / r;u = rad * u + uCenter;\nv = rad * v + vCenter;return vec2(u/aspectRatio, v);\n}out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfloat aspectRatio = uResolution.x/uResolution.y;\nuv.x = uv.x * aspectRatio;\nvec2 sphereCoords = uv;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\npos.x *= aspectRatio;float radius = 0.7900 * uResolution.x/max(uResolution.x, uResolution.y);if(1 == 0) {\nsphereCoords = sphericalTransformation(\nmix(sphereCoords.x, 1.-sphereCoords.x, 1.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 1.0000),\nmix(pos.x, 1.-pos.x, 1.0000),\nmix(pos.y, 1.-pos.y, 1.0000),\nradius/2.,\n1. + 0.9500 * 9.\n);\n} else if(1 == 1) {\nsphereCoords = discTransformation(\nmix(sphereCoords.x, 1.-sphereCoords.x, 1.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 1.0000),\nmix(pos.x, 1.-pos.x, 1.0000),\nmix(pos.y, 1.-pos.y, 1.0000),\nradius/2.,\n1. + 0.9500 * 9.\n);\n} else if(1 == 2) {\nsphereCoords = fisheyeTransformation(\nmix(sphereCoords.x, 1.-sphereCoords.x, 1.0000),\nmix(sphereCoords.y, 1.-sphereCoords.y, 1.0000),\nmix(pos.x, 1.-pos.x, 1.0000),\nmix(pos.y, 1.-pos.y, 1.0000),\nradius/2.,\n1. + 0.9500 * 9.\n);\n}vec2 scaledCoords = (sphereCoords - 0.5) + 0.5;\nvec4 sphere = texture(uTexture, clamp(scaledCoords, 0.0, 1.0));\nfloat distFromPos = distance(uv, pos);\nfloat edgeSmooth = 0.001;\nfloat insideSphere = 1.0 - smoothstep(radius/2.0 - edgeSmooth, radius/2.0, distFromPos);\nfloat insideSphereAlpha = 1.0 - smoothstep(radius/2.0 + 0.002 - edgeSmooth, radius/2.0 + 0.002, distFromPos);\nsphere.rgb = chromaticAbberation(scaledCoords, atan(scaledCoords.y, scaledCoords.x), distFromPos * 2.0500, 1.0);\ncolor = mix(color, sphere, insideSphere);\ncolor.rgb += vec3((0.1700-0.5)*2.) * mix(0., circularIn(smoothstep(0., radius, distFromPos)), insideSphere);\nif(0 == 1) {\ncolor.a = insideSphereAlpha;\ncolor.rgb = mix(vec3(0), color.rgb, insideSphereAlpha);\n}\nvec2 maskPos = mix(vec2(0), (uMousePos - 0.5), 0.0000);\nvec4 maskColor = texture(uMaskTexture, vTextureCoord - maskPos);\ncolor = color * (maskColor.a * maskColor.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect9"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"projection","usesPingPong":false,"trackMouse":0.01,"trackAxes":"xy","mouseMomentum":1,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;const float PI = 3.14159265;vec3 getRayDirection(vec2 uv, vec2 mousePos, float aspect) {\nvec2 screenPos = (uv - 0.5) * 2.0;\nscreenPos.x *= aspect;\nscreenPos.y *= -1.0;\nfloat minFOV = radians(20.0);\nfloat maxFOV = radians(120.0);\nfloat fov = mix(minFOV, maxFOV, 0.5000);\nvec3 rayDir = normalize(vec3(screenPos.x * tan(fov/2.0),\nscreenPos.y * tan(fov/2.0),\n-1.0));\nfloat rotX = (mousePos.y - 0.5) * PI;\nfloat rotY = (mousePos.x - 0.5) * PI * 2.0;\nmat3 rotateY = mat3(\ncos(rotY), 0.0, -sin(rotY),\n0.0, 1.0, 0.0,\nsin(rotY), 0.0, cos(rotY)\n);\nmat3 rotateX = mat3(\n1.0, 0.0, 0.0,\n0.0, cos(rotX), sin(rotX),\n0.0, -sin(rotX), cos(rotX)\n);\nreturn normalize(rotateX * rotateY * rayDir);\n}vec2 directionToUVHorizontal(vec3 dir) {\nfloat longitude = atan(dir.z, dir.x);\nfloat latitude = acos(dir.y);\nvec2 uv;\nuv.x = longitude / (2.0 * PI) + 0.5;\nuv.y = latitude / PI;\nuv.x += 0.25;\nreturn uv;\n}vec2 directionToUVVertical(vec3 dir) {\nfloat longitude = atan(dir.z, dir.y);\nfloat latitude = acos(dir.x);\nvec2 uv;\nuv.y = longitude / PI * -1.;\nuv.x = (latitude / (2.0 * PI) + 0.5) * -1.;\nuv.x = fract(uv.x + 0.25);\nreturn uv;\n}out vec4 fragColor;vec4 getRepeatHorizontalUV(vec2 uv) {\nvec2 finalUV = vec2(fract(uv.x), uv.y);\nvec4 col = texture(uTexture, finalUV);\nif (0.0000 > 0.0) {\nfloat blendWidth = 0.0000 * 0.1;\nfloat blendFactor = 0.0;\nif (finalUV.x < blendWidth) {\nblendFactor = 1.0 - (finalUV.x / blendWidth);\n} else if (finalUV.x > 1.0 - blendWidth) {\nblendFactor = (finalUV.x - (1.0 - blendWidth)) / blendWidth;\n}\nif (blendFactor > 0.0) {\nblendFactor = smoothstep(0.0, 1.0, blendFactor);\nvec2 oppositeUV = vec2(finalUV.x > 0.5 ? finalUV.x - 0.5 : finalUV.x + 0.5, finalUV.y);\nvec4 oppositeCol = texture(uTexture, oppositeUV);\ncol = mix(col, oppositeCol, blendFactor);\n}\n}\nreturn col;\n}vec4 getRepeatUV(vec2 uv) {\nreturn getRepeatHorizontalUV(uv);\n}void main() {\nfloat aspect = 2.;\nvec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0100 * 0.5);\nvec3 rayDir = getRayDirection(vTextureCoord, mPos, aspect);\nvec2 uvHorizontal = directionToUVHorizontal(rayDir);\nvec2 uvVertical = directionToUVVertical(rayDir);\nvec2 sphereUV = mix(uvHorizontal, uvVertical, 0.5000);\nfloat minFOV = radians(20.0);\nfloat maxFOV = radians(120.0);\nfloat currentFOV = mix(minFOV, maxFOV, 0.5000);\nfloat fovCompensation = tan(currentFOV/2.0);\nfloat compensatedScale = (mix(-0.1, 0.4, 0.1400) * 12.0 + 2.0) * (1.0/fovCompensation);\nsphereUV = (sphereUV - 0.5) * compensatedScale + 0.5;sphereUV += vec2(0.5, 0) * uTime * 0.005;vec4 col = getRepeatUV(sphereUV);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect10"}],"options":{"name":"Orbi (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.0","id":"0M9Py3VSUQcq6cucLcEh"}
