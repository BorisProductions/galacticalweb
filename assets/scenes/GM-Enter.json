{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 drawPoint(vec2 uv, vec2 center, float scale) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;\nvec2 skew = vec2(0.5000, 1. - 0.5000) * 2.;\nuv = uv * rot(0.0000 * TWO_PI) * skew;\ncenter = center * rot(0.0000 * TWO_PI) * skew;\nfloat dist = distance(uv, center);\nfloat radius = scale * 0.25;float brightness = radius / dist;\nbrightness = mix(brightness, brightness*brightness, 0.5000);\nreturn brightness * vec3(0.08235294117647059, 0.08235294117647059, 0.08235294117647059);\n}vec3 getBeam(vec2 uv) {\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawPoint(uv, pos, 0.5000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb);\nvec3 result = mix(bg.rgb, blended, 1.0000);\nresult += dither;vec4 color = vec4(result, max(bg.a, luma(beam)));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"fog","usesPingPong":false,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.5000, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 0));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.5000, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(0, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.5000, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, 1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nfloat getExponentialWeight(int index) {\nswitch(index) {\ncase 0: return 1.0000000000;\ncase 1: return 0.7165313106;\ncase 2: return 0.5134171190;\ncase 3: return 0.3678794412;\ncase 4: return 0.2636050919;\ncase 5: return 0.1888756057;\ncase 6: return 0.1353352832;\ncase 7: return 0.0969670595;\ncase 8: return 0.0694877157;\ndefault: return 0.0;\n}\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 ExponentialBlur(sampler2D tex, vec2 uv, vec2 direction) {\nvec4 color = vec4(0.0);\nfloat total_weight = 0.0;float fogNoise = fnoise(uv);\nfloat radius = 8.0 * fogNoise * max(0.5000, 0.1);\nradius = mix(0.01, 0.03, radius);vec2 dir = normalize(direction) / vec2(uResolution.x/uResolution.y, 1);vec4 center = texture(tex, uv);\nfloat center_weight = getExponentialWeight(0);\ncolor += center * center_weight;\ntotal_weight += center_weight;for (int i = 1; i <= 8; i++) {\nfloat weight = getExponentialWeight(i);\nfloat offset = radius * float(i) / 8.0;\nvec4 sample1 = texture(tex, uv + offset * dir);\nvec4 sample2 = texture(tex, uv - offset * dir);\ncolor += (sample1 + sample2) * weight;\ntotal_weight += 2.0 * weight;\n}\nfloat scatter = radius * 2.;\ncolor += (\ntexture(tex, uv + scatter * dir) +\ntexture(tex, uv - scatter * dir)\n) * 0.0694877157;return color / total_weight;\n}vec4 blur(vec2 uv, vec2 direction) {\nreturn ExponentialBlur(uTexture, uv, direction);\n}vec4 getColor(vec2 uv) {\nreturn blur(uv, vec2(1, -1));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}","#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform sampler2D uBgTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const int kernelSize = 36;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 Tonemap_ACES(vec3 x) {\nconst float a = 2.51;\nconst float b = 0.03;\nconst float c = 2.43;\nconst float d = 0.59;\nconst float e = 0.14;\nreturn (x * (a * x + b)) / (x * (c * x + d) + e);\n}vec3 chromatic_aberration(vec3 color, vec2 uv, float amount) {\nvec2 offset = normalize(vTextureCoord - 0.5) * amount / vec2(uResolution.x/uResolution.y, 1);\nvec4 left = texture(uTexture, uv - offset);\nvec4 right = texture(uTexture, uv + offset);color.r = left.r;\ncolor.b = right.b;return color;\n}const float PHI = 1.618033988;\nconst float PI = 3.14159265359;float dot_noise(vec3 p) {\nconst mat3 GOLD = mat3(\n-0.571464913, +0.814921382, +0.096597072,\n-0.278044873, -0.303026659, +0.911518454,\n+0.772087367, +0.494042493, +0.399753815);\nreturn dot(cos(GOLD * p), sin(PHI * p * GOLD));\n}float cheap_fbm(vec3 p) {\nmat2 rota = mat2(0.6, -0.8, 0.8, 0.6);\nfloat nos = 0.;\nfloat amp = 1. + 0.5000 * 10.;\nfloat xp = sqrt(2.);\nfloat halfxp = xp * 0.5;\nfor(int i = 0; i < 6; i++) {\nfloat theta = uTime * 0.05 + float(i);\np.xy *= xp;\np.xy += sin(rota * p.xy * xp + theta) * 0.2;\nfloat nz = dot_noise(vec3(p.xy * rota, p.z + theta));\nnos += nz * amp * rota[0][0];\namp *= halfxp;\nrota *= mat2(0.6, -0.8, 0.8, 0.6);\n}\nnos *= 1./float(6);\nfloat density = -3. + 0.5000 * 6.;\nreturn smoothstep(-3., 3., nos + density);\n}float fnoise(vec2 uv) {\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1);\nfloat multiplier = 10.0 * (0.5000 / ((aspectRatio + 1.) / 2.));\nvec2 st = ((uv * aspect - vec2(0.5, 0.5) * aspect)) * multiplier * rot((0.0000 - 0.125) * 2. * PI);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * aspect, mPos * aspect) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nfloat time = uTime * 0.05;\nvec2 drift = vec2(time * 0.2) * 2.0 * 0.5000;\nfloat fbm = cheap_fbm(vec3(st - drift, time)) * dist;\nfbm = fbm / (1. + fbm);\nreturn fbm;\n}vec4 fogComposite(vec2 uv) {\nvec4 bg = texture(uBgTexture, uv);\nvec4 blur = texture(uTexture, uv);\nfloat aspectRatio = uResolution.x/uResolution.y;\nfloat fogNoise = fnoise(uv);\nfloat fogMask = clamp(fogNoise * 2., 0., 1.);vec3 grain = vec3(randFibo(uv + fogNoise));blur.rgb = chromatic_aberration(blur.rgb, uv, fogMask * 0.01 * 0.5000 * (0.5000 * 2.5));\nblur.rgb = Tonemap_ACES(blur.rgb * (0.5000 + 0.5)) + grain * 0.05;\nvec4 foggedBlur = vec4(blur.rgb * vec3(1, 1, 1), blur.a);\nfoggedBlur.rgb += (0.1000 * 0.25 * fogMask * vec3(1, 1, 1));\nfoggedBlur = mix(bg, foggedBlur, fogMask);\nreturn foggedBlur;\n}vec4 getColor(vec2 uv) {\nreturn fogComposite(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 color = getColor(uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":0.25},{"prop":"pass","value":2,"downSample":0.25},{"prop":"pass","value":3,"downSample":0.25},{"prop":"pass","value":4,"includeBg":true}]},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"flowField","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}vec3 hash33(vec3 p3) {\np3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\np3 += dot(p3, p3.yxz + 19.19);\nreturn -1.0 + 2.0 * fract(vec3(\n(p3.x + p3.y) * p3.z,\n(p3.x + p3.z) * p3.y,\n(p3.y + p3.z) * p3.x\n));\n}float perlin_noise(vec3 p) {\nvec3 pi = floor(p);\nvec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0)));\nfloat n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0)));\nfloat n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0)));\nfloat n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0)));\nfloat n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0)));\nfloat n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0)));\nfloat n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0)));\nfloat n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x);\nfloat nx01 = mix(n001, n101, w.x);\nfloat nx10 = mix(n010, n110, w.x);\nfloat nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y);\nfloat nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz;\n}const float MAX_ITERATIONS = 16.;\nvec2 flow (in vec2 st) {\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1. - distance(st * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));float sprd = (0.5000 + 0.01) / ((aspectRatio + 1.) / 2.);\nfloat amt = 0.5000 * 0.01 * dist;\nif(amt <= 0.) {\nreturn st;\n}vec2 invPos = 1. - pos;\nfloat freq = 5. * sprd;\nfloat t = 0.0000*5. + uTime/60.;\nfloat degrees = 360. * (0.5000 * 6.);\nfloat radians = degrees * 3.1415926 / 180.;for (float i = 0.; i < MAX_ITERATIONS; i++) {\nvec2 scaled = (st - 0.5) * vec2(aspectRatio, 1) + invPos;\nfloat perlin = perlin_noise(vec3((scaled - 0.5) * freq, t)) - 0.5;\nfloat ang = perlin * radians;\nst += vec2(cos(ang), sin(ang)) * amt;\nst = clamp(st, 0., 1.);\n}return st;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, mix(uv, flow(uv), 1.0000));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"aspectRatio":1.6,"userDownsample":1,"effects":["1bdc0907-00a4-4923-b694-4f1bd9482a80","8b204262-60db-428b-a73b-97d7fbccc06e"],"anchorPoint":0,"mask":0,"maskDepthLayer":1,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":478,"widthMode":1,"height":215,"heightMode":1,"left":0.2875,"top":0.18888888888888888,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0.1607843137254902, 0.1607843137254902, 0.1607843137254902);\ncase 2: return vec3(0.39215686274509803, 0.39215686274509803, 0.39215686274509803);\ncase 3: return vec3(0.615686274509804, 0.615686274509804, 0.615686274509804);\ncase 4: return vec3(0.8156862745098039, 0.8156862745098039, 0.8156862745098039);\ncase 5: return vec3(1, 1, 1);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 0.2000;\ncase 2: return 0.4000;\ncase 3: return 0.6000;\ncase 4: return 0.8000;\ncase 5: return 1.0000;\ncase 6: return 1.2000;\ncase 7: return 1.4000;\ncase 8: return 1.6000;\ncase 9: return 1.8000;\ncase 10: return 2.0000;\ncase 11: return 2.2000;\ncase 12: return 2.4000;\ncase 13: return 2.6000;\ncase 14: return 2.8000;\ncase 15: return 3.0000;\ndefault: return 0.0;\n}\n}uniform vec2 uArtboardResolution;uniform vec2 uMousePos;const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.0, 0.0);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(rgb, vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(lin, vec3(1.0/2.2));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);vec3 lms1 = pow(kCONEtoLMS * lin1, vec3(1.0/3.0));\nvec3 lms2 = pow(kCONEtoLMS * lin2, vec3(1.0/3.0));\nvec3 lms = mix(lms1, lms2, a);\nlms *= 1.0 + 0.025 * a * (1.0 - a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nif (6 <= 1) return getColor(0);for (int i = 0; i < 15; i++) {\nif (i >= 6 - 1) break;\nfloat stopA = getStop(i);\nfloat stopB = getStop(i + 1);\nif (position <= stopB || i == 6 - 2) {\nfloat denom = max(stopB - stopA, 0.00001);\nfloat t = clamp((position - stopA) / denom, 0.0, 1.0);\nvec3 linA = linear_from_srgb(getColor(i));\nvec3 linB = linear_from_srgb(getColor(i + 1));\nvec3 mixed = oklab_mix(linA, linB, t);\nreturn srgb_from_linear(mixed);\n}\n}\nreturn getColor(min(6 - 1, 15));\n}vec3 getLinearGradientColor(vec2 p, vec2 halfSize, float angle) {\nvec2 d = vec2(cos(angle) * halfSize.x, sin(angle) * halfSize.y);\nfloat dd = max(dot(d, d), 0.00001);\nfloat pos = 0.5 + 0.5 * (dot(p, d) / dd);\nreturn getGradientColor(pos);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;float angle = 0.0000 * TAU;\nreturn getLinearGradientColor(p, halfSize, angle);return getColor(0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);halfSize = uArtboardResolution * 0.5;\np = canvasPosPx - halfSize;\nreturn sdBox(p, halfSize);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = 478.0000;\nfloat absHeight = 215.0000;if (1 == 2) {\nabsWidth = absHeight * 1.6000;\n} else if (1 == 2) {\nabsHeight = absWidth / 1.6000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.2875, 0.1889) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = canvasPosPx;\nvec2 localSize;\nlocalSize = uArtboardResolution;\nvec2 centerPx;\ncenterPx = uArtboardResolution * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getSourceOutput(vec2 uv) {\nreturn sampleShape(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0000;uv -= pos;fragColor = getSourceOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.6}},"compositeShader":{"fragmentShader":"#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uBgTexture;\nuniform sampler2D uTexture;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0);uv -= pos;vec4 background = vec4(0);background = texture(uBgTexture, vTextureCoord);\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}","vertexShader":"#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"},"compositeUniforms":{"resolution":{"name":"uResolution","type":"2f","value":{"type":"Vec2","_x":1080,"_y":1080}},"opacity":{"name":"uOpacity","type":"1f","value":1},"mousePos":{"name":"uMousePos","type":"2f","value":{"type":"Vec2","_x":0.5,"_y":0.5}}}},"id":"shape"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"blinds","usesPingPong":false,"speed":0.5,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;float ease (int easingFunc, float t) {\nreturn t;\n}const float STEPS = 10.0;\nconst float PI = 3.14159265359;mat2 rot(float a) {\nreturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}vec2 scaleAspect(vec2 st, float aspectRatio) {\nreturn st * vec2(aspectRatio, 1.0);\n}vec2 unscaleAspect(vec2 st) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nreturn st * vec2(1.0/aspectRatio, 1.0);\n}struct StructFunc {\nvec2 st;\nvec3 distort;\n};StructFunc style0(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) {\nfloat segment = fract((st.y + 1. - pos.y - 1. + uTime * 0.01) * divisions);\nsegment = mix(segment, smoothstep(0.0, 0.5, segment) - smoothstep(0.5, 1.0, segment), 0.0000);\nvec3 distort = mix(mix(first, second, segment * 2.), mix(second, third, (segment - 0.5) / (1. - 0.5)), step(0.5, segment));\nst.y -= pow(distort.r, dist) / 10. * amount;\nst.y += pow(distort.b, dist) / 10. * amount;st = rot(0.0000 * 2. * PI) * (st - pos) + pos;\nst = unscaleAspect(st);return StructFunc(st, distort);\n}StructFunc getStyle(vec2 st, vec2 pos, float divisions, float dist, float amount, vec3 first, vec3 second, vec3 third) {\nreturn style0(st, pos, divisions, dist, amount, first, second, third);\n}vec4 blinds(vec2 st, float mDist) {\nfloat aspectRatio = uResolution.x / uResolution.y;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.0000) * floor(1.0000);\npos = scaleAspect(pos, aspectRatio);\nst = scaleAspect(st, aspectRatio);st = rot(0.0000 * -2.0 * PI) * (st - pos) + pos;vec3 first = vec3(1, 0, 0);\nvec3 second = vec3(0, 1, 0);\nvec3 third = vec3(0, 0, 1);\nfloat divisions = 2. + 0.5000 * 30.;\nfloat dist = 0.2000 * 4. + 1.;\nfloat amount = 0.5000 * mDist;vec2 texelX = dFdx(st) * 1.5;\nvec2 texelY = dFdy(st) * 1.5;\nStructFunc result = getStyle(st, pos, divisions, dist, amount, first, second, third);\nStructFunc result1 = getStyle(st + texelX, pos, divisions, dist, amount, first, second, third);\nStructFunc result2 = getStyle(st + texelY, pos, divisions, dist, amount, first, second, third);\nStructFunc result3 = getStyle(st - texelX, pos, divisions, dist, amount, first, second, third);\nStructFunc result4 = getStyle(st - texelY, pos, divisions, dist, amount, first, second, third);vec2 offset = (result.st + result1.st + result2.st + result3.st + result4.st) / 5.;\nvec4 color = texture(uTexture, offset);return color;\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x / uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat mDist = ease(0, max(0., 1. - distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));vec4 col = blinds(uv, mDist);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sdf_shape","usesPingPong":false,"texture":false,"speed":0.5,"trackMouseMove":0,"trackAxes":"xy","mouseMomentum":0,"trackMouse":0,"parentLayer":"1bdc0907-00a4-4923-b694-4f1bd9482a80","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;\nuniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos;\nuniform vec2 uResolution;uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}const float PI = 3.141592653;\nconst float PI2 = 6.283185306;\nconst int DISP_STEPS = 12;\nconst vec3 viewDir = vec3(0,0, -4.25);ivec2 customTexSize;\nfloat customTexAspect;const mat3 ROT_Y_90 = mat3(\n0.0, 0.0, 1.0,\n0.0, 1.0, 0.0,\n-1.0, 0.0, 0.0\n);const mat3 ROT_Z_90 = mat3(\n0.0, -1.0, 0.0,\n1.0, 0.0, 0.0,\n0.0, 0.0, 1.0\n);const mat3 ROT_X_90 = mat3(\n1.0, 0.0, 0.0,\n0.0, 0.0, -1.0,\n0.0, 1.0, 0.0\n);mat3 rotY(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}mat3 rotX(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}mat3 rotZ(float ang) {\nfloat c = cos(ang), s = sin(ang);\nreturn mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}vec3 twistY(vec3 p, float amount) {\nfloat c = cos(amount * p.y);\nfloat s = sin(amount * p.y);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(m * p.xz, p.y);\n}vec3 twistX(vec3 p, float amount) {\nfloat c = cos(amount * p.x);\nfloat s = sin(amount * p.x);\nmat2 m = mat2(c, -s, s, c);\nreturn vec3(p.x, m * p.yz);\n}float smin(float a, float b, float k) {\nfloat h = max(k - abs(a - b), 0.0);\nreturn min(a, b) - h * h * 0.25 / k;\n}float honeycomb(vec3 p, float r) {\nvec3 np = normalize(p);\nfloat latitude = acos(np.x);\nfloat freq = 10.0;\nfloat phase = 1. + uTime * 0.2;\nfloat wave = sin(latitude * freq + phase) * cos(latitude * freq + phase);\nfloat waveAmplitude = 0.01 + 0.5000 * 0.1;\nfloat modifiedRadius = r + wave * waveAmplitude;\nfloat baseSphere = length(p) - r * 0.8;\nfloat modifiedSphere = length(p) - modifiedRadius;\nreturn smin(baseSphere, modifiedSphere, 0.01);\n}float sdStar5(vec2 p, float r, float rf)\n{\nconst vec2 k1 = vec2(0.809016994375, -0.587785252292);\nconst vec2 k2 = vec2(-k1.x,k1.y);\np.x = abs(p.x);\np -= 2.0*max(dot(k1,p),0.0)*k1;\np -= 2.0*max(dot(k2,p),0.0)*k2;\np.x = abs(p.x);\np.y -= r;\nvec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\nfloat h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\nreturn length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}vec3 getRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getThreeDRepeat(vec3 p) {\nfloat spacing = (0.5000 + 0.0000 * 0.38) * 8.;\nreturn p;\n}vec3 getAdjustedP(vec3 p) {\nfloat scale = max(0.3600, 0.000000001);\nfloat scaleFactor = 1.0/scale;\nvec3 adjustedP = p * scaleFactor;vec2 twist = vec2(0, 0);adjustedP.xy *= vec2(uResolution.x / uResolution.y, 1);adjustedP *= (1. + (0.0000 + 0.01));vec2 mousePos = mix(vec2(0), uMousePos - 0.5, 0.0000);\nvec2 axis = vec2(-1. * vec3(0.8445692883895131, 0.5745817727840199, 0.2222222222222222).y - 1. + mousePos.y/PI, vec3(0.8445692883895131, 0.5745817727840199, 0.2222222222222222).x + mousePos.x/PI) * 2.;adjustedP = getRepeat(adjustedP);float baseTime = uTime * 0.02;\nfloat timeX = vec3(0, 1, 0).x * baseTime;\nfloat timeY = vec3(0, 1, 0).y * baseTime;\nfloat timeZ = vec3(0, 1, 0).z * baseTime;mat3 rotYMat = rotY(axis.y * PI);\nmat3 rotXMat = rotX(axis.x * PI);\nmat3 rotZMat = rotZ(vec3(0.8445692883895131, 0.5745817727840199, 0.2222222222222222).z * 2.0 * PI);mat3 combinedRotation = rotZMat * rotYMat * rotXMat;\nmat3 combinedAnimation = rotZ(timeZ) * rotX(timeX) * rotY(timeY);adjustedP = combinedRotation * adjustedP;\nadjustedP = combinedAnimation * adjustedP;\nadjustedP = getThreeDRepeat(adjustedP);\nadjustedP = mix(adjustedP, twistY(adjustedP, -1.0 * twist.y), step(0.0, abs(twist.y)));\nadjustedP = mix(adjustedP, twistX(adjustedP, -1.0 * twist.x), step(0.0, abs(twist.x)));return adjustedP;\n}float getMergedSDF(vec3 p) {\np = getAdjustedP(p);\nreturn honeycomb(p, 1.);\n}float fresnel(vec3 eyeVector, vec3 worldNormal, float power) {\nfloat NdotV = abs(dot(eyeVector, worldNormal));\nfloat width = fwidth(dot(eyeVector, worldNormal));\nfloat threshold = 0.2;\nfloat edgeDampFactor = smoothstep(threshold, -threshold, width);\nfloat fresnelFactor = 1.0 - NdotV;\nreturn pow(fresnelFactor, power) * mix(1., edgeDampFactor * 2., 0.5);\n}vec3 noFrostOrDispersion(vec3 rd, vec3 normal) {\nfloat ior = 1.0 / (1.0 + 0.5000 * 0.25);\nvec3 refractedRay = refract(rd, normal, ior);\nreturn texture(uTexture, vTextureCoord - refractedRay.xy).rgb;\n}vec3 frostOrDispersion(vec3 rd, vec3 normal) {\nvec3 refractionColor = vec3(0);\nfloat iorBase = 1. + 0.5000 * 0.25;vec3 dispCoefficients = vec3(0.03, 0.06, 0.1) * 0.2500 * 1.2;for (int i = 0; i < DISP_STEPS; ++i) {\nfloat step = float(i) / float(DISP_STEPS);\nvec3 disp = step * dispCoefficients;\nvec3 ior = 1.0 / (iorBase + disp);vec3 refractedRayR = refract(rd, normal, ior.r);\nvec3 refractedRayG = refract(rd, normal, ior.g);\nvec3 refractedRayB = refract(rd, normal, ior.b);refractionColor.r += texture(uTexture, vTextureCoord - refractedRayR.xy).r;\nrefractionColor.g += texture(uTexture, vTextureCoord - refractedRayG.xy).g;\nrefractionColor.b += texture(uTexture, vTextureCoord - refractedRayB.xy).b;\n}return clamp(refractionColor / float(DISP_STEPS), 0.0, 1.0);\n}vec3 calculateNormal(vec3 p, float eps) {\nvec2 e = vec2(1.0, -1.0) * eps * 0.5;\nreturn normalize(\ne.xyy * getMergedSDF(p + e.xyy) +\ne.yyx * getMergedSDF(p + e.yyx) +\ne.yxy * getMergedSDF(p + e.yxy) +\ne.xxx * getMergedSDF(p + e.xxx)\n);\n}vec3 sampleTexture(vec3 rd, vec3 normal) {return frostOrDispersion(rd, normal);\nreturn noFrostOrDispersion(rd, normal);\n}float scene(vec3 p) {\nreturn max(0.0000000001, getMergedSDF(p) - (0.0000 + 0.005)) * max(0.3600, 0.000000001);\n}const int STEPS = 128;\nconst float MAX_DISTANCE = 100.0;vec4 rayMarch(vec3 ro, vec3 rd) {\nfloat pixelSize = 0.0025;\nfloat traveled = 0.;\nvec3 entryPoint = vec3(0.0);\nvec3 entryNormal = vec3(0.0);\nfloat partialAlpha = 0.0;\nfloat lastDistance = 0.0;\nfloat smoothing = mix(1., 4., 0.2000);for (int i = 0; i < STEPS; ++i) {\nvec3 currentPos = ro + rd * traveled;\nfloat distance = scene(currentPos);\nfloat progress = float(i)/float(STEPS);\nfloat step = distance * mix(1., 1.5, progress);if (distance > MAX_DISTANCE) break;if (distance < pixelSize) {\npartialAlpha = 1.;\nentryPoint = currentPos;\nentryNormal = calculateNormal(entryPoint, pixelSize * smoothing);\nbreak;\n}lastDistance = distance;traveled += max(step, pixelSize);\nif (traveled > MAX_DISTANCE) break;\n}if (partialAlpha == 0.0) {\nreturn vec4(0);\n}vec3 samplePosition = mix(rd, entryPoint, 0.0000);vec3 refractionColor = texture(uTexture, vTextureCoord).rgb;refractionColor = sampleTexture(samplePosition, entryNormal);\nvec3 lightDir = vec3(((vec2(vec3(0.25, 0.25, -3).x, 1.-vec3(0.25, 0.25, -3).y) - 0.333) * 3.) - vec2(0.5, 0.5), vec3(0.25, 0.25, -3).z);\nvec3 normLightDir = normalize(lightDir);float lightAndShadow = dot(entryNormal, normLightDir);\nvec3 lightColor = mix(vec3(1), vec3(1, 1, 1), 1. - 0.0000);\nvec3 fresnelEffect = vec3(0.0);fresnelEffect = fresnel(rd, entryNormal, 8.0) * 0.5000 * vec3(1, 1, 1);vec3 specularEffect = vec3(0.0);vec3 halfwayDir = normalize(lightDir + rd);\nfloat specFactor = pow(max(dot(entryNormal, halfwayDir), 0.0), 64.0 * 0.5000 + 0.01);\nspecularEffect = specFactor * 0.5000 * lightColor;vec3 combinedEffects = fresnelEffect + specularEffect;\nvec3 finalColor = mix(refractionColor, vec3(1, 1, 1) * lightAndShadow, 0.0000);\nfinalColor += combinedEffects;vec4 outputColor = vec4(finalColor, 1.);return outputColor;\n}out vec4 fragColor;void main() {\nvec4 col = vec4(0);\nvec4 bg = texture(uTexture, vTextureCoord);if(0.3600 <= 0.0001 || 1.0000 <= 0.0001) {\ncol = vec4(0);\nif(0 == 1) {\ncol = bg;\n}\nfragColor = col;\nreturn;\n}vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 uv = vTextureCoord - pos;\nfloat fovFactor = tan(radians(20.) * 0.5);\nvec3 rd = vec3(uv * fovFactor, 0.5);\ncol = rayMarch(viewDir, rd);\nfloat dither = (randFibo(vTextureCoord.xy) - 0.5) / 255.0;\ncol += dither;col = mix(vec4(0), col, 1.0000);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect5"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/media/glyphs/remix_vertical_lines.png","sampler":"uSprite"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"parentLayer":"8b204262-60db-428b-a73b-97d7fbccc06e","animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.7200);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 0.4000), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(0 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(0 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uSprite, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"effect6"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"duotone","usesPingPong":false,"texture":false,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;out vec4 fragColor;\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);\nfloat gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));\nvec3 duotoneColor = mix(vec3(1, 1, 1), vec3(0.2980392156862745, 0, 0.9686274509803922), gray);\ncolor = vec4(mix(color.rgb, duotoneColor, 1.0000), color.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect7"}],"options":{"name":"Planet (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"2.0.0","id":"6pxF46MQs0F4D96y4Zzk"}
